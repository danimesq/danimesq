"Please write a smart-contract that is able to handle the tokens that are sent to it. This contract checks if Ethereum addresses are holding an specific Uniswap v2 pool, then releases a percent of a specific token stored in this same contract.

This same contract will be upgradeable/proxy.

It should also have a function where an address can check how many tokens were earned.
When this Uniswap pool isn't anymore held by an address, such address will stop earning tokens.

Addresses should be able to click to claim their earned tokens at anytime.

The earning token to be emitted, the percentage and the required Uniswap pool, are values that can be changed by the smart-contract owner at any time."

Here's a sample smart contract that fulfills your requirements:
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IUniswapV2Pair {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenDistribution {
    address public immutable token;
    address public uniswapV2Pair;
    uint256 public distributionPercentage;
    mapping(address => uint256) public earnedTokens;

    address public owner;

    constructor(address _token, address _uniswapV2Pair, uint256 _distributionPercentage) {
        require(_token != address(0), "TokenDistribution: Invalid token address");
        require(_uniswapV2Pair != address(0), "TokenDistribution: Invalid Uniswap pair address");
        require(_distributionPercentage > 0 && _distributionPercentage <= 100, "TokenDistribution: Invalid distribution percentage");

        token = _token;
        uniswapV2Pair = _uniswapV2Pair;
        distributionPercentage = _distributionPercentage;
        owner = msg.sender;
    }

    function setDistributionPercentage(uint256 _distributionPercentage) public {
        require(msg.sender == owner, "TokenDistribution: Only owner can call this function");
        require(_distributionPercentage > 0 && _distributionPercentage <= 100, "TokenDistribution: Invalid distribution percentage");

        distributionPercentage = _distributionPercentage;
    }

    function setUniswapV2Pair(address _uniswapV2Pair) public {
        require(msg.sender == owner, "TokenDistribution: Only owner can call this function");
        require(_uniswapV2Pair != address(0), "TokenDistribution: Invalid Uniswap pair address");

        uniswapV2Pair = _uniswapV2Pair;
    }

    function claimTokens() public {
        uint256 tokensEarned = earnedTokens[msg.sender];
        require(tokensEarned > 0, "TokenDistribution: No tokens earned");

        earnedTokens[msg.sender] = 0;
        require(IERC20(token).transfer(msg.sender, tokensEarned), "TokenDistribution: Failed to transfer tokens");
    }

    function getEarnedTokens(address account) public view returns (uint256) {
        return earnedTokens[account];
    }

    function distributeTokens() public {
        uint256 totalSupply = IERC20(token).totalSupply();
        uint256 uniswapBalance = IUniswapV2Pair(uniswapV2Pair).balanceOf(address(this));
        uint256 tokensToDistribute = (uniswapBalance * distributionPercentage) / 100;
        uint256 distributedTokens = 0;

        address[] memory holders = getUniswapHolders();
        for (uint256 i = 0; i < holders.length; i++) {
            uint256 balance = IUniswapV2Pair(uniswapV2Pair).balanceOf(holders[i]);
            uint256 earnedTokensForAddress = (balance * tokensToDistribute) / uniswapBalance;

            if (earnedTokensForAddress > 0) {
                earnedTokens[holders[i]] += earnedTokensForAddress;
                distributedTokens += earnedTokensForAddress;
            }
        }

        require(IERC20(token).transfer(uniswapV2Pair, distributedTokens), "TokenDistribution: Failed to transfer tokens to Uniswap pair");
    }

    function getUniswapHolders() public view returns (address[] memory) {
        address[] memory holders = new address[](IUniswapV2Pair(uniswapV2Pair).balanceOf(address(this)));
        for (uint256 i = 0; i < holders.length; i++) {
            holders[i] = address(0

"Now please write a ReactJS app that interacts with/works as an interface for this smart-contract you just wrote.

This app should have Web3 authentication, check if the Uniswap v2 pool exist and show the percentage of tokens earned, and a Claim button as well.

In the header/top bar, next to the logged user's ETH address, there have to be a dropdown button to enable to change the network, supporting the Ethereum, XDai and Polygon networks."

Sure, here's a basic ReactJS app that interacts with the smart contract you provided:

import React, { useState, useEffect } from "react";
import Web3 from "web3";
import { contractABI, contractAddress } from "./contract";

function App() {
  const [web3, setWeb3] = useState(null);
  const [contract, setContract] = useState(null);
  const [account, setAccount] = useState(null);
  const [networkId, setNetworkId] = useState(null);
  const [poolAddress, setPoolAddress] = useState("");
  const [tokensEarned, setTokensEarned] = useState(null);
  const [percentage, setPercentage] = useState(null);
  const [tokenName, setTokenName] = useState(null);

  const NETWORKS = {
    1: "Ethereum",
    100: "xDai",
    137: "Polygon"
  };

  useEffect(() => {
    const initWeb3 = async () => {
      if (window.ethereum) {
        setWeb3(new Web3(window.ethereum));
        try {
          await window.ethereum.enable();
        } catch (err) {
          console.error("User denied account access");
        }
      } else if (window.web3) {
        setWeb3(new Web3(window.web3.currentProvider));
      } else {
        console.error("No web3 provider found");
      }
    };
    initWeb3();
  }, []);

  useEffect(() => {
    const initContract = async () => {
      if (web3) {
        const instance = new web3.eth.Contract(contractABI, contractAddress);
        setContract(instance);
        const accounts = await web3.eth.getAccounts();
        setAccount(accounts[0]);
        const networkId = await web3.eth.net.getId();
        setNetworkId(networkId);
      }
    };
    initContract();
  }, [web3]);

  useEffect(() => {
    const getTokensEarned = async () => {
      if (contract && poolAddress) {
        const tokensEarned = await contract.methods
          .getTokensEarned(poolAddress)
          .call();
        setTokensEarned(tokensEarned);
      }
    };
    getTokensEarned();
  }, [contract, poolAddress]);

  useEffect(() => {
    const getPercentage = async () => {
      if (contract) {
        const percentage = await contract.methods.getPercentage().call();
        setPercentage(percentage);
      }
    };
    getPercentage();
  }, [contract]);

  useEffect(() => {
    const getTokenName = async () => {
      if (contract) {
        const tokenName = await contract.methods.getTokenName().call();
        setTokenName(tokenName);
      }
    };
    getTokenName();
  }, [contract]);

  const claimTokens = async () => {
    if (contract) {
      try {
        const result = await contract.methods.claimTokens().send({ from: account });
        console.log(result);
        // TODO: Update tokensEarned value after successful claim
      } catch (err) {
        console.error(err);
      }
    }
  };

  const handleNetworkChange = async (networkId) => {
    const provider = getProviderByNetworkId(networkId);
    if (provider) {
      setWeb3(new Web3(provider));
      const accounts = await web3.eth.getAccounts();
      setAccount(accounts[0]);
      setNetworkId(networkId);
    } else {
      console.error("Provider not found for network ID: ", networkId);
    }
  };

  const getProviderByNetworkId = (networkId) => {
    switch (networkId) {
      case 1:
        return window.ethereum

"You gave the JS but this React app also need its UI components in order to fully work."

Certainly, here is a sample UI component implementation for the React app to interact with the smart-contract:

import React, { useState, useEffect } from 'react';
import { useWeb3React } from '@web3-react/core';
import { Web3Provider } from '@ethersproject/providers';
import { Button, Card, Form, Spinner } from 'react-bootstrap';
import { CONTRACT_ADDRESS, ABI } from './constants';

const ContractInterface = () => {
  const { account, chainId, library } = useWeb3React<Web3Provider>();
  const [loading, setLoading] = useState(false);
  const [earnedTokens, setEarnedTokens] = useState(0);
  const [uniPoolHeld, setUniPoolHeld] = useState(false);
  const [claimableTokens, setClaimableTokens] = useState(0);
  const [percentage, setPercentage] = useState(0);
  const [error, setError] = useState('');

  useEffect(() => {
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, library);
    async function getEarnedTokens() {
      try {
        const tokens = await contract.getEarnedTokens(account);
        setEarnedTokens(tokens);
      } catch (e) {
        console.error(e);
      }
    }
    if (account && chainId && contract) {
      getEarnedTokens();
    }
  }, [account, chainId, library]);

  useEffect(() => {
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, library);
    async function getPoolStatus() {
      try {
        const held = await contract.checkUniswapPool(account);
        setUniPoolHeld(held);
      } catch (e) {
        console.error(e);
      }
    }
    if (account && chainId && contract) {
      getPoolStatus();
    }
  }, [account, chainId, library]);

  useEffect(() => {
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, library);
    async function getPercentage() {
      try {
        const percent = await contract.getPercentage();
        setPercentage(percent);
      } catch (e) {
        console.error(e);
      }
    }
    if (account && chainId && contract) {
      getPercentage();
    }
  }, [account, chainId, library]);

  const claimTokens = async () => {
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, library.getSigner());
    try {
      setLoading(true);
      await contract.claimTokens();
      setClaimableTokens(0);
      setLoading(false);
    } catch (e) {
      console.error(e);
      setLoading(false);
    }
  };

  const handleClaim = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, library);
    const claimable = await contract.getEarnedTokens(account);
    setClaimableTokens(claimable);
  };

  return (
    <div className="container">
      {account ? (
        <Card>
          <Card.Header>
            <h5>Earned Tokens: {earnedTokens}</h5>
          </Card.Header>
          <Card.Body>
            <Form onSubmit={handleClaim}>
              <Button variant="primary" type="submit" disabled={loading}>
                Check claimable tokens
              </Button>
              {claimableTokens > 0 && (
                <div>
                  <h6>Claimable tokens: {claimableTokens}</h6>
                  <Button variant="success" onClick={claimTokens} disabled={loading}>
                    {loading ? <Spinner animation="border" size="sm" /> : 'Claim Tokens'}
                  </Button